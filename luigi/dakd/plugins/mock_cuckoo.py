import  os
import json
import sys, traceback
import shutil
import time
import yaml
import requests
import re
from .plugin_utils import create_pluginlogger
from .plugin_utils import pluginLoggerDecorator
from .plugin_utils import shellexec
from .plugin_utils import shellexecV
from .dakd_cuckoo import dakd_plugin as nonmockin_plugin

def initConf():
    """
        every plugin uses its own config file
    """
    return yaml.load(open(os.path.abspath(__file__).replace('.py','.conf'),'r'))

conf = initConf()
extractLogger = create_pluginlogger(conf["logger_extract"],conf)
transformLogger = create_pluginlogger(conf["logger_transform"],conf)



class dakd_plugin(nonmockin_plugin):
    """
        only methods that change from the base class are written here
    """

    taskid = ""
    filepath = ""
    #---------plugin-code--------------------------------------------------


    





    @pluginLoggerDecorator(extractLogger)
    def submit(self, newfilepath):
        """ Runs a procmon prepared analysis """

        # prepare paths
        filepath = newfilepath.strip()
        self.filepath = filepath

        
        #nothing to submit



        return True


    @pluginLoggerDecorator(extractLogger)
    def status(self):
        """
        No status implemented, so return True
        """
        return True


    @pluginLoggerDecorator(extractLogger)
    def download(self, folderpath):
        """ download from cuckoo web server and save to file """
        
        report = json.load(open(conf["mock_cuckoo_report"],'r'))

        self.runFileTestGatherResults(
                filename=self.filepath, 
                destination=folderpath,
                report=report)
        
        return True
       

    # @pluginLoggerDecorator(transformLogger)
    # def parse(self, filepath):
    #     """

    #        APIStats
    #         r['behavior']['apistats']
    #         r['behavior']['processes'][?][calls]
            
    #         Procmon:
    #         r['procmon'][?]['Path']
    #         r['procmon'][?]['Operation']
    #         if r['procmon'][i]['Process_name'] == process_name


    #         returns a dictionary
    #     """

    #     report = json.load(open(filepath,'r'))

    #     filename = os.path.basename(filepath)
    #     auxname = filename.split(".")
    #     auxname = filename[:filename.index(auxname[-1])]+"exe"
        


    #     try:

    #         result={}
    #         # extract all api stats
    #         result["apistats"] = report['behavior']['apistats']

    #         # extract all imagepath
    #         result_procmon = {}
            
    #         if 'procmon' in report.keys():
    #             for event in report['procmon']:
    #                 try:
    #                     if event['Process_Name'].startswith(auxname):

    #                         op = event["Operation"]
    #                         path = event["Path"]
    #                         #id = op+"_"+path
    #                         id = path
    #                         if id in list(result_procmon.keys()):
    #                             result_procmon[id]+=1
    #                         else:
    #                             result_procmon[id]=1

    #                 except:
    #                     continue

            
    #         result["procmon"] = result_procmon

    #         result["hash"] = ""
    #         try:
    #             if 'sha256' in report['target']['file']:
    #                 #r['virustotal']['sha256']
    #                 result["hash"] = {}
    #                 result["hash"]['sha256'] = report['target']['file']['sha256']
    #                 result["hash"]['sha512'] = report['target']['file']['sha512']
    #                 result["hash"]['sha1'] = report['target']['file']['sha1']
    #                 result["hash"]['md5'] = report['target']['file']['md5']
    #         except Exception as e:
    #             transformLogger.exception("some error in target sha256 parsing")
    #             transformLogger.error(e, exc_info=True)


    #         result["label"] = "unknown"

    #         if 'virustotal' in report.keys():
    #             try:
    #                 transformLogger.debug("virustotal analysis ")
    #                 transformLogger.debug(report['virustotal']['positives'])



    #                 if int(report['virustotal']['positives'])>0:
    #                     #somehow extract the first or the more recurrent classifications
    #                     # or take a sole antivirus... Symantec, Kaspersky...

    #                     detection = ""
    #                     for av in conf["Antivirus"]:
    #                         if report['virustotal']['scans'][av]['detected']==True:
    #                             detection = report['virustotal']['scans'][av]['result']
    #                             break    

    #                     # acronyms extracted from analysi
    #                     acronyms = re.split('\.|:|/', detection)

    #                     transformLogger.debug("detection acronyms:")
    #                     transformLogger.debug(acronyms)

    #                     # from more specificc category to more gen√®ric category, look all acronyms for each
    #                     for cat in conf["categories"]:
    #                         for category, subcategories in cat.items():
    #                             transformLogger.debug(" category: "+category)
    #                             transformLogger.debug(subcategories)
    #                             for acronym in acronyms:
    #                                 if acronym.lower() in [subcat.lower() for subcat in subcategories]:
    #                                     result["label"] = category
    #                                     break

    #                     transformLogger.debug("label: ")
    #                     transformLogger.debug(result["label"])
            
    #             except Exception as e:
    #                 transformLogger.exception("some error in virustotal parsing")
    #                 transformLogger.error(e, exc_info=True)

    #         return (os.path.basename(filepath), result, result["label"])

    #     except Exception as e:
    #         transformLogger.exception("filename not found! "+auxname)
    #         #traceback.print_exc(file=sys.stdout)
    #         transfromLogger.error(e, exc_info=True)
        

    #     return


    # @pluginLoggerDecorator(extractLogger)
    # def runFileTestGatherResults(self, filename, destination, report):

    #     # move exe file to destination folder
    #     fileout = os.path.join(os.path.abspath(destination),os.path.basename(filename))
    #     if os.path.exists(destination):
    #         shutil.move(filename, fileout)

    #     # move log file to destination folder
    #     filename = os.path.basename(filename)
    #     auxname = filename.split(".")
    #     auxname = filename[:filename.index(auxname[-1])]+conf["log_file_extension"]
    #     logout = os.path.join(destination,auxname)

    #     f = open(logout,'w')
    #     json.dump(report, f)
        
