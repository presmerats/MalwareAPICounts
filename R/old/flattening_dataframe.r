
library(jsonlite)
library(data.table)
setwd("/home/homero/KDB/Projectes/dakd-project/R")

# main json data file
jsonData <- fromJSON(txt = "../luigi/lvl4/binaries_labelled.df")

flatten.frame <- function(jsonData){
  flat.frame <- data.frame(name=jsonData$name, label=jsonData$label)
  
  
  
  # hash information
  hashcols=do.call(rbind, lapply(jsonData[c('hash')], '['))
  #hashcols$name <- jsonData$name
  names(flat.frame)
  names(hashcols)
  #nrow(hashcols)
  #nrow(flat.frame)
  flat.frame <- cbind(flat.frame, hashcols)
  names(flat.frame)
  
  head(hashcols)
  head(flat.frame)
  
  missing.Names <- function(name, md5){
    
    # print(length(xrow))
    # print(names(xrow))
    # print(colnames(xrow))
    # print(xrow[1])
    # print(xrow[5])
    # print(xrow[1]=="res")
    if (name=="res") {
      name <- paste("VirusShare_",md5,sep="")
    }
    #print(xrow)
    return(name)
  }
  
  
  flat.frame$name <-  mapply(missing.Names, flat.frame$name, flat.frame$md5)
  
  #flat.frame <- t(apply(flat.frame, 1, missing.Names ))
  colnames(flat.frame)
  #flat.frame
  head(flat.frame)
  tail(flat.frame)
  
  
  # apistats
  # create a loop for the previous set of operations on the data frame
  input.frame <- jsonData[,c('name','apistats')]
  
  for (elem in colnames(input.frame$apistats)){
    #get the corresponding apistats associated with an element
    current_apistats =  do.call(rbind, lapply(input.frame[c('apistats')], '[[', elem))
    
    # for each api call of that apistats, create a new column 
    for (i in colnames(current_apistats) ) {
      
      # get as a new colum/vector
      x <- current_apistats[[i]]
      
      # transform NA's to 0
      x[is.na(x)] <- 0
      
      
      # if it already exists, just sum the values of each row
      if(i %in% colnames(flat.frame)){
        flat.frame[[i]] <- flat.frame[[i]] + x
        
      } else {
        # if that column name doesn't exists, append it to the data frame
        #flat.frame <- cbind(flat.frame,x)
        flat.frame[[i]] <- x
      }
      
      #print(head(flat.frame[,c(1,2,length(colnames(flat.frame))-1, length(colnames(flat.frame)))],20))
      
    }
    
  }

  return(flat.frame)  
}

flat.frame <- data.frame(name=jsonData$name, label=jsonData$label)



# hash information
hashcols=do.call(rbind, lapply(jsonData[c('hash')], '['))
#hashcols$name <- jsonData$name
names(flat.frame)
names(hashcols)
#nrow(hashcols)
#nrow(flat.frame)
flat.frame <- cbind(flat.frame, hashcols)
names(flat.frame)

head(hashcols)
head(flat.frame)

missing.Names <- function(name, md5){

  # print(length(xrow))
  # print(names(xrow))
  # print(colnames(xrow))
  # print(xrow[1])
  # print(xrow[5])
  # print(xrow[1]=="res")
  if (name=="res") {
   name <- paste("VirusShare_",md5,sep="")
  }
  #print(xrow)
  return(name)
}


flat.frame$name <-  mapply(missing.Names, flat.frame$name, flat.frame$md5)

#flat.frame <- t(apply(flat.frame, 1, missing.Names ))
colnames(flat.frame)
#flat.frame
head(flat.frame)
tail(flat.frame)


# apistats
# create a loop for the previous set of operations on the data frame
input.frame <- jsonData[,c('name','apistats')]

for (elem in colnames(input.frame$apistats)){
  #get the corresponding apistats associated with an element
  current_apistats =  do.call(rbind, lapply(input.frame[c('apistats')], '[[', elem))
  
  # for each api call of that apistats, create a new column 
  for (i in colnames(current_apistats) ) {
    
    # get as a new colum/vector
    x <- current_apistats[[i]]
    
    # transform NA's to 0
    x[is.na(x)] <- 0
    
    
    # if it already exists, just sum the values of each row
    if(i %in% colnames(flat.frame)){
      flat.frame[[i]] <- flat.frame[[i]] + x
      
    } else {
      # if that column name doesn't exists, append it to the data frame
      #flat.frame <- cbind(flat.frame,x)
      flat.frame[[i]] <- x
    }
    
    #print(head(flat.frame[,c(1,2,length(colnames(flat.frame))-1, length(colnames(flat.frame)))],20))
    
  }
  
}

nrow(flat.frame)
ncol(flat.frame)
head(flat.frame[,c(1,2,100,200,290)])

missing.Labels <- function(name, label){
  if (startsWith(name,"VirusShare_") ){
    return ("malicious")
  } else {
    return("safe")
  }
}


random.Labels <- function(name, label){
  if (endsWith(name,"4") || endsWith(name,"6") || endsWith(name,"8") ){
    return ("ransomware")
  } else if (endsWith(name,"1") || endsWith(name,"2") || endsWith(name,"5") ){
    return ("trojan")
  } else if (endsWith(name,"3") || endsWith(name,"7") || endsWith(name,"9") ){
    return ("adware")
  } else if (endsWith(name,"0") || endsWith(name,"a") || endsWith(name,"d") ){
    return ("dropper")
  } else {
    return("safe")
  }
}

##########LDA Test01########################################


flat.frame$label <-  mapply(missing.Labels, flat.frame$name, flat.frame$label)

#https://tgmstat.wordpress.com/2014/01/15/computing-and-visualizing-lda-in-r/
library(MASS)
LDA1 <- lda(flat.frame[c(7:100)],flat.frame[,2])
LDA1
LDA1$counts
LDA1$means
LDA1$svd
LDA1$scaling

dataset <- data.frame(label=flat.frame[,2], lda=)


##########LDA test02###################################

trainData <- jsonData[c(1:99,200:600,1100:1259),]
trainData <- flatten.frame(trainData)
#trainData$label <-  mapply(missing.Labels, trainData$name, trainData$label)
#trainData$label <-  mapply(random.Labels, trainData$name, trainData$label)
trainData[trainData$label!='unknown',c(1,2,200)]


testData <- jsonData[c(100:200,600:1100),]
testData <- flatten.frame(testData)
# testData has no label!
testData[testData$label!='unknown',c(1,2,200)]



#https://tgmstat.wordpress.com/2014/01/15/computing-and-visualizing-lda-in-r/
library(MASS)
library(ggplot2)
require(gridExtra)
ncol(trainData)
lda.model <- lda(trainData[c(7:250)],trainData[,2])
plot(lda.model)

lda.model2 <- lda(trainData[,2] ~ ., data=trainData[c(7:250)])
lda.prediction <- predict(object = lda.model2, newdata = testData)
dataset <- data.frame(label=lda.prediction$class, reallabel=testData[,2])

names(lda.prediction)
colnames(lda.prediction$class)
head(lda.prediction$class, n=6L)
colnames(lda.prediction$posterior)
head(lda.prediction$posterior)
colnames(lda.prediction$x)
head(lda.prediction$x)
head(lda.prediction, n=6L)
head(dataset)

#ggplot(dataset, aes(x=NtOpenSection, y=GetNativeSystemInfo, colour=label)) + geom_point()
p1 <- ggplot(dataset, aes(x=lda1.LD1, y=lda1.LD2, colour=label, shape=label)) + geom_point() + 
p2 <- ggplot(dataset, aes(x=lda1.LD1, y=lda1.LD3, colour=label, shape=label)) + geom_point()
p3 <- ggplot(dataset, aes(x=lda1.LD1, y=lda1.LD4, colour=label, shape=label)) + geom_point()
p4 <- ggplot(dataset, aes(x=lda1.LD2, y=lda1.LD3, colour=label, shape=label)) + geom_point()
p5 <- ggplot(dataset, aes(x=lda1.LD2, y=lda1.LD4, colour=label, shape=label)) + geom_point()
p6 <- ggplot(dataset, aes(x=lda1.LD3, y=lda1.LD4, colour=label, shape=label)) + geom_point()

grid.arrange(p1,p2,p3,p4,p5,p6)
#######################################


# Procmon 
procmoncols=do.call(rbind, lapply(jsonData[c('procmon')], '['))
# clean NA
for (col in colnames(procmoncols)){
  procmoncols[[col]][is.na(procmoncols[[col]])] <- 0
  
}
ncol(flat.frame)
head(procmoncols[,c(1:10)])
ncol(procmoncols)
nrow(procmoncols)

# make sure there are no repetitions? sum?
#colnames(procmoncols)

# append cols into a dataframe..
data <- cbind(flat.frame, procmoncols)
nrow(data)
ncol(data)
head(data[,c(1,2,100,200,800)])
