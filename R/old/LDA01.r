
library(jsonlite)
library(data.table)
setwd("/home/homero/KDB/Projectes/dakd-project/R")

# main json data file
jsonData <- fromJSON(txt = "../luigi/lvl4/binaries_labelled.df")

flatten.frame <- function(jsonData){
  flat.frame <- data.frame(name=jsonData$name, label=jsonData$label)
  
  
  
  # hash information
  hashcols=do.call(rbind, lapply(jsonData[c('hash')], '['))
  #hashcols$name <- jsonData$name
  names(flat.frame)
  names(hashcols)
  #nrow(hashcols)
  #nrow(flat.frame)
  flat.frame <- cbind(flat.frame, hashcols)
  names(flat.frame)
  
  head(hashcols)
  head(flat.frame)
  
  missing.Names <- function(name, md5){
    
    # print(length(xrow))
    # print(names(xrow))
    # print(colnames(xrow))
    # print(xrow[1])
    # print(xrow[5])
    # print(xrow[1]=="res")
    if (name=="res") {
      name <- paste("VirusShare_",md5,sep="")
    }
    #print(xrow)
    return(name)
  }
  
  
  flat.frame$name <-  mapply(missing.Names, flat.frame$name, flat.frame$md5)
  
  #flat.frame <- t(apply(flat.frame, 1, missing.Names ))
  colnames(flat.frame)
  #flat.frame
  head(flat.frame)
  tail(flat.frame)
  
  
  # apistats
  # create a loop for the previous set of operations on the data frame
  input.frame <- jsonData[,c('name','apistats')]
  
  for (elem in colnames(input.frame$apistats)){
    #get the corresponding apistats associated with an element
    current_apistats =  do.call(rbind, lapply(input.frame[c('apistats')], '[[', elem))
    
    # for each api call of that apistats, create a new column 
    for (i in colnames(current_apistats) ) {
      
      # get as a new colum/vector
      x <- current_apistats[[i]]
      
      # transform NA's to 0
      x[is.na(x)] <- 0
      
      
      # if it already exists, just sum the values of each row
      if(i %in% colnames(flat.frame)){
        flat.frame[[i]] <- flat.frame[[i]] + x
        
      } else {
        # if that column name doesn't exists, append it to the data frame
        #flat.frame <- cbind(flat.frame,x)
        flat.frame[[i]] <- x
      }
      
      #print(head(flat.frame[,c(1,2,length(colnames(flat.frame))-1, length(colnames(flat.frame)))],20))
      
    }
    
  }

  return(flat.frame)  
}




##########LDA test02###################################

nrow(jsonData)
trainData <- jsonData[c(1:99,200:600,1100:1326),]
trainData <- flatten.frame(trainData)
trainData[trainData$label!='unknown',c(1,2,200)]


testData <- jsonData[c(100:200,600:1100,1327:1426),]
testData <- flatten.frame(testData)
testData[testData$label!='unknown',c(1,2,200)]



#https://tgmstat.wordpress.com/2014/01/15/computing-and-visualizing-lda-in-r/
library(MASS)
library(ggplot2)
require(gridExtra)

ncol(trainData)
#lda.model <- lda(trainData[c(7:250)],trainData[,2])
#plot(lda.model)

lda.model2 <- lda(trainData[,2] ~ ., data=trainData[c(7:250)])
lda.prediction <- predict(object = lda.model2, newdata = testData)
dataset <- data.frame(label=lda.prediction$class, lda=lda.prediction$x, hash=testData[,3] ,reallabel=testData[,2])

# names(lda.prediction)
colnames(lda.prediction$class)
# head(lda.prediction$class, n=6L)
# colnames(lda.prediction$posterior)
# head(lda.prediction$posterior)
colnames(lda.prediction$x)
# head(lda.prediction$x)
# head(lda.prediction, n=6L)
head(dataset)
colnames(dataset)

#ggplot(dataset, aes(x=NtOpenSection, y=GetNativeSystemInfo, colour=label)) + geom_point()
p1 <- ggplot(dataset, aes(x=lda.LD1, y=lda.LD2, colour=label, shape=reallabel)) + geom_point() + geom_text(aes(label=hash), size=3)
p1 
# rows to discard
# c3121bb053a1...
# ...98397c5

nrow(dataset)
h <- dataset$hash
length(h)
h[endsWith(paste(h,sep=""),"98397c5")]
length(h2)
h[ startsWith(paste(h,sep=""),"c3121bb053a1")]

i=0
for (j in 1:length(h)) {
  #print(j)
  aux <- paste(h[j],sep="")
  #print(aux)
  if ( startsWith(aux,"ca94cd82f12ee15d3801190bedfbb6085707215061c836b72b5cbb2f598397c5") ) {
    print(j)
  } else if (startsWith(aux,"c3121bb053a1da05d15d7e5481eacaa900620dca61d38709a9b7a47ed684dde5") ){
    print(j)
  } 
}
# remove: ca94cd82f12ee15d3801190bedfbb6085707215061c836b72b5cbb2f598397c5 -> row 132
# remove: c3121bb053a1da05d15d7e5481eacaa900620dca61d38709a9b7a47ed684dde5 -> row 614

length(h)


testData_clean = testData[c(1:131,133:613,615:702),]
lda.prediction <- predict(object = lda.model2, newdata = testData_clean)
dataset <- data.frame(label=lda.prediction$class, lda=lda.prediction$x, hash=testData_clean[,3] ,reallabel=testData_clean[,2])
p1 <- ggplot(dataset, aes(x=lda.LD1, y=lda.LD2, colour=label, shape=reallabel)) +
      geom_point() +
      coord_cartesian(ylim=c(-20,20),xlim=c(-50,50))
      


p2 <- ggplot(dataset, aes(x=lda.LD1, y=lda.LD3, colour=label, shape=reallabel)) +
  geom_point() +
  coord_cartesian(ylim=c(-20,20),xlim=c(-50,50))


p3 <- ggplot(dataset, aes(x=lda.LD1, y=lda.LD4, colour=label, shape=reallabel)) +
  geom_point() +
  coord_cartesian(ylim=c(-20,20),xlim=c(-50,50))

p4 <- ggplot(dataset, aes(x=lda.LD2, y=lda.LD3, colour=label, shape=reallabel)) +
  geom_point() +
  coord_cartesian(ylim=c(-20,20),xlim=c(-50,50))

p5 <- ggplot(dataset, aes(x=lda.LD2, y=lda.LD4, colour=label, shape=reallabel)) +
  geom_point() +
  coord_cartesian(ylim=c(-20,20),xlim=c(-50,50))

p6 <- ggplot(dataset, aes(x=lda.LD3, y=lda.LD4, colour=label, shape=reallabel)) +
  geom_point() +
  coord_cartesian(ylim=c(-20,20),xlim=c(-50,50))

grid.arrange(p1,p2,p3,p4,p5,p6)
grid.arrange(p4,p6)

#######################################


# Procmon 
procmoncols=do.call(rbind, lapply(jsonData[c('procmon')], '['))
# clean NA
for (col in colnames(procmoncols)){
  procmoncols[[col]][is.na(procmoncols[[col]])] <- 0
  
}
ncol(flat.frame)
head(procmoncols[,c(1:10)])
ncol(procmoncols)
nrow(procmoncols)

# make sure there are no repetitions? sum?
#colnames(procmoncols)

# append cols into a dataframe..
data <- cbind(flat.frame, procmoncols)
nrow(data)
ncol(data)
head(data[,c(1,2,100,200,800)])
