


model.evaluation <- function(dataset, rate=TRUE){
  #accurate <- dataset[ which(dataset$reallabel == dataset$label), ]
  #nrow(accurate)
  errors <- dataset[ which(dataset$reallabel != dataset$label),]
  #print(nrow(errors))
  if(rate){
    accuracy <- round(1 - nrow(errors)/nrow(dataset),4)
  } else {
    accuracy <- nrow(dataset) - nrow(errors)
  }
  #accuracy <- nrow(errors)
  return(accuracy)
}




num.princomp.validation <- function(csvData2){
  np=100
  accuracies <- c(rep(5,np))
  for (i in 1:np){
    
    pca.dataset <- pca.computation(csvData2,i)
    
    # partition dataset
    trainingset <- pca.dataset[c(1:(nrow(pca.dataset)/2) ),]
    testset <- pca.dataset[c( (nrow(pca.dataset)/2):nrow(pca.dataset)),]
    
    # train the model
    lda.model <- lda(trainingset$label ~ ., data=trainingset)
    
    # prediction
    lda.prediction <- model.predictor(lda.model,testset)
    
    # accuracy computation
    accuracies[i] <- model.evaluation(lda.prediction)
    
    print(paste("num pca",(5+i),"accuracy",accuracies[i]))
  }
  
  p1 <- plot(accuracies)
  p1
  return(accuracies)
}




fold.validation <- function(trainingSet, testingSet, model_type="pcafda"){
  drops <- c("name", "sha1", "sha256", "sha512")
  trainingSet <- trainingSet[, !(names(trainingSet) %in% drops)]
  testingSet <- testingSet[, !(names(testingSet) %in% drops)]
  
  #str(trainingSet)
  
  #print("training model...")
  if(model_type=="pcafda"){
    mod <- fda.model.training(trainingSet)
    result.set <- fda.model.predictor(mod, testingSet)
  } else if (model_type=="svm") {
    mod <- svm.model.training(trainingSet)
    result.set <- svm.model.predictor(mod, testingSet)
  } else if (model_type=="random") {
    result.set <- random.model.predictor(testingSet)
  } else {
    result.set <- majority.model.predictor(testingSet)
  }
  
  #print("computing accuracy...")
  accuracy.value <- model.evaluation(result.set,FALSE)
  return(accuracy.value)
}

create.K.folds <- function(dataset, k ){
  n = nrow(dataset)
  fold.length = floor(n/k)
  fold <- list()
  for (i in 1:k){
    i1 <- (i-1)*fold.length + 1
    i2 <- i*fold.length
    if (i==k & i2 < n){
      i2 <- n
    }
    fold[[i]] <- dataset[c(i1:i2),]
    
    print(paste("fold rows",i1, i2))
    #print(head(colnames(dataset[c(i1:i2),])))
    #print(head(colnames(fold[[i]])))
  }
  
  return(fold)
}

create.stratified.proportional.K.folds <- function(dataset, k){
  
  # strategy 1: all class fold the same length (length of the smallest class fold)
  # strategy 2: all class fold their own length, but all folds with the same proportions
  # here: strategy 2
  
  n = nrow(dataset)
  fold.length = floor(n/k)
  fold <- list()
  
  labels <- levels(dataset$label)
  classes.length <- rep(1:length(labels))
  classes.fold.lengths <- rep(1:length(labels))
  classes.subsets <- list()
  # get elems in each label
  for (j in 1:length(labels)){
    # compute label.fold.length
    subset1 <- dataset[which(dataset$label == labels[j]),]
    classes.subsets[[j]] <- subset1
    l = nrow(subset1)
    kj = floor(l/k)
    #print(paste("subsetting for label",labels[j]," nrows",l," kfold length",kj))
    classes.length[j] <- l
    classes.fold.lengths[j] <- kj
    
  }
  
  for (i in 1:k){
    
    # create the new fold as an empty data frame
    fold[[i]] <- dataset[0,]
    
    # for each class
    for (j in 1:length(classes.length)){
      # get the class fold length, 
      fold.length <- classes.fold.lengths[j]
      nj <- classes.length[j]
      
      i1 <- (i-1)*fold.length + 1
      i2 <- i*fold.length
      if (i==k & i2 < nj){
        i2 <- nj
      }
      
      #then add to the current fold
      fold[[i]] <- rbind(fold[[i]], classes.subsets[[j]][c(i1:i2),])
      
      #print(paste("fold ", i ," class", labels[j]," class legnth", nj, " class fold length", fold.length ," fold rows",i1, i2))
      #print(head(colnames(dataset[c(i1:i2),])))
      #print(head(colnames(fold[[i]])))
      
    }
    
    
  }
  
  return(fold)
}

create.stratified.equal.K.folds <- function(dataset, k){
  
  # strategy 1: all class fold the same length (length of the smallest class fold)
  # strategy 2: all class fold their own length, but all folds with the same proportions
  # here: strategy 1
  
  n = nrow(dataset)
  fold.length = floor(n/k)
  fold <- list()
  
  labels <- levels(dataset$label)
  classes.length <- rep(1:length(labels))
  classes.fold.lengths <- rep(1:length(labels))
  classes.subsets <- list()
  # get elems in each label
  for (j in 1:length(labels)){
    # compute label.fold.length
    subset1 <- dataset[which(dataset$label == labels[j]),]
    classes.subsets[[j]] <- subset1
    l = nrow(subset1)
    kj = floor(l/k)
    print(paste("subsetting for label",labels[j]," nrows",l," kfold length",kj))
    classes.length[j] <- l
    classes.fold.lengths[j] <- kj
    
  }
  
  # get the minimum of all labels for length and kfold length
  min.length = min(classes.length)
  min.fold.length = min(classes.fold.lengths)
  print(paste("min lengtn", min.length, "min fold lengt ", min.fold.length))
  
  for (i in 1:k){
    
    # create thenew fold as an empty data frame
    fold[[i]] <- dataset[0,]
    
    # for each class
    for (j in 1:length(classes.length)){
      # get the class fold length, 
      fold.length <- min.fold.length
      nj <- min.length
      
      i1 <- (i-1)*fold.length + 1
      i2 <- i*fold.length
      if (i==k & i2 < nj){
        i2 <- nj
      }
      
      #then add to the current fold
      fold[[i]] <- rbind(fold[[i]], classes.subsets[[j]][c(i1:i2),])
      
      print(paste("fold ", i ," class", labels[j]," class legnth", nj, " class fold length", fold.length ," fold rows",i1, i2))
      #print(head(colnames(dataset[c(i1:i2),])))
      #print(head(colnames(fold[[i]])))
    }
  }
  return(fold)
}


kfold.stratified.validation <- function(dataset, model_type="pcafda"){
  # divide test and training in K stratified folds
  k=10
  n=nrow(dataset)
  #fold <- create.K.folds(dataset, k, n)
  fold <- create.stratified.proportional.K.folds(dataset,k)
  #fold <- create.stratified.equal.K.folds(dataset,k)
  
  # compute  model and validation on each fold
  accuracies <- rep(0,k)
  for (i in 1:k){
    test.set = fold[[i]]
    
    #print("Test set:")
    #print(nrow(test.set))
    #print(head(names(test.set)))
    
    #print("training folds")
    # get the columns
    training.set <- test.set[0,]
    
    if (i>1) {
      for (j in 1:(i-1) ){
        #print(paste(" i",i,"j",j))
        training.set <- rbind(training.set,fold[[j]])
        #print(nrow(training.set))
      }  
    }
    
    if (i < k ){
      for (j in (i+1):k){
        if (j <= k){
          #print(paste(" i",i,"j",j))
          training.set <- rbind(training.set,fold[[j]])
          #print(nrow(training.set))
        }
      }  
    }
    
    #print(head(fold))
    #print(paste("computing model for fold ",i))
    #print(nrow(training.set))
    #print(nrow(test.set))
    #print(head(names(training.set)))
    #print(head(names(test.set)))
    
    accuracies[i] <- fold.validation(training.set, test.set, model_type)
    print(paste("----> accuracy",accuracies[i],"/",nrow(test.set)," = ", round(accuracies[i]/nrow(test.set),2)))
  }
  
  return(sum(accuracies)/n)
  
}





